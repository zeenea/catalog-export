/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.zeenea.cli.export;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.ParameterException;
import com.zeenea.cli.export.xlsx.ColumnExport;
import com.zeenea.cli.export.xlsx.ExportStyles;
import com.zeenea.cli.export.xlsx.SheetExport;
import com.zeenea.client.api.StreamResult;
import com.zeenea.client.api.ZeeneaClient;
import com.zeenea.client.api.asset.*;
import com.zeenea.client.api.id.Nature;
import com.zeenea.client.api.property.*;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * Classe d'export du catalogue Zeenea.
 * <p>Elle export le catalogue Zeenea dans un fichier Excel.
 * Trois onglets contient les trois objets principaux du catalogue:</p>
 * <ol>
 *     <li>les catégories,</li>
 *     <li>les datasets,</li>
 *     <li>les champs (<i>fields</i>)</li>
 * </ol>
 */
public class ExportCatalog {
    private static final int ID_WIDTH = 36;
    private static final int TEXT_WIDTH = 20;
    private static final int DESCRIPTION_WIDTH = 70;
    private static final int TIMESTAMP_WIDTH = 19;
    private static final int NUMBER_WIDTH = 10;
    private static final int BOOLEAN_WIDTH = 3;

    private static final Logger log = LoggerFactory.getLogger(ExportCatalog.class);

    private final ExportParams params;
    private final ZeeneaClient client;
    private final CategoryApi categoryApi;
    private final DatasetApi datasetApi;
    private final FieldApi fieldApi;

    /**
     * Construit un {@link ExportCatalog}
     *
     * @param params Paramètres de l'export.
     * @param client Client Zeenea.
     */
    public ExportCatalog(ExportParams params, ZeeneaClient client) {
        this.params = params;
        this.client = client;
        this.categoryApi = client.getCategoryApi();
        this.datasetApi = client.getDatasetApi();
        this.fieldApi = client.getFieldApi();
    }

    /**
     * Fonction principale du programme.
     * Elle est exécutée par le script de lancement de l'application.
     *
     * @param args Argument de la ligne de commande.
     */
    public static void main(String[] args) {
        try {
            ExportParams exportParams = parseExportParams(args);

            try (ZeeneaClient client = ZeeneaClient.connect(exportParams.toZeeneaConfig())) {
                new ExportCatalog(exportParams, client).exportCatalog();
            }

        } catch (ParameterException e) {
            System.err.println(e.getMessage());
            System.err.println();
            e.usage();
            System.exit(1);

        } catch (Exception e) {
            log.error("Something bad happened in ExportCatalog", e);
            System.exit(1);
        }
    }

    /**
     * Analyse les arguements fournis en ligne de commande et construit un {@link ExportParams} contenant les valeurs lues.
     *
     * <p>Lors que l'aide est demandé avec les options {@code -h} ou {@code --help}, l'aide en ligne est
     * affiché sur la sortie standard et le programme s'arrête avec un code re retour normal.</p>
     *
     * <h3>Détails d'implantation</h3>
     * <p>Cette fonction utilise la bibliothèque JCommander pour analyser et valider les arguements de la ligne
     * de commande.</p>
     *
     * @param args arguments de la ligne de commande.
     * @return un {@link ExportParams} contenant les valeurs des arguments analysés.
     * @see <a href="http://jcommander.org/">La documentation de JCommander</a> (en).
     */
    @Nonnull
    private static ExportParams parseExportParams(String[] args) {
        ExportParams exportParams = new ExportParams();
        JCommander jCommander = JCommander.newBuilder()
            .programName("catalog-export")
            .addObject(exportParams)
            .build();
        jCommander.parse(args);

        if (exportParams.isHelp()) {
            jCommander.usage();
            System.exit(0);
        }

        return exportParams;
    }


    /**
     * Réalise l'export du catalogue.
     *
     * @throws UncheckedIOException En cas d'erreur d'écriture du fichier Excel d'export.
     */
    public void exportCatalog() {
        SXSSFWorkbook workbook = new SXSSFWorkbook();
        try {
            ExportStyles exportStyles = ExportStyles.of(workbook);

            exportAsset(
                Nature.Category,
                workbook,
                exportStyles,
                this::prepareCategoryExportMainSection,
                categoryApi::listAll
            );

            exportAsset(
                Nature.Dataset,
                workbook,
                exportStyles,
                this::prepareDatasetExportMainSection,
                datasetApi::listAll
            );

            exportAsset(
                Nature.Field,
                workbook,
                exportStyles,
                this::prepareFieldExportMainSection,
                fieldApi::listAll
            );

            try {
                try (OutputStream out = openExportFile()) {
                    workbook.write(out);
                }
            } catch (IOException ioe) {
                throw new UncheckedIOException(ioe);
            }
        } finally {
            workbook.dispose();
        }
    }

    /**
     * Méthode modèle pour l'export d'un asset.
     *
     * <p>L'export de l'asset est paramétré par le {@link Consumer} {@code preparation} qui permet de définir les
     * champs principaux à exporter.</p>
     *
     * <h3>Détails d'implantation</h3>
     * <p>
     * La méthode:
     * <ol>
     *     <li>crée un object d'export vers une nouvelle feuille Excel,</li>
     *     <li>prépare l'export avec le consumer {@code preparation} fournie,</li>
     *     <li>ajoute l'export des propriétés dynamiques de l'asset,</li>
     *     <li>requête Zeenea à partir de la {@code query} fournie en paramètres,</li>
     *     <li>effectue l'export à partir du résultat.</li>
     * </ol>
     *
     * <p>Notez que les résultats de l'API Zeenea sont automatiquement et naturellement paginés.
     * De même que l'API utilisée pour l'écriture du fichier Excel est conçue pour consommer le minimum de mémoire possible.
     * Exporter une collection très grande ne devrait pas posser de problèmes particulier.</p>
     *
     * @param nature       Nature de l'asset à exporter.
     * @param workbook     Document Excel de travail.
     * @param exportStyles Cache des styles utilisés pour l'export.
     * @param preparation  Méthode de préparation de l'export.
     * @param query        Requête auprès de l'API Zeenea utile pour l'export de l'asset.
     * @param <T>          Type de l'asset exporté.
     */
    private <T extends Asset> void exportAsset(Nature nature,
                                               Workbook workbook,
                                               ExportStyles exportStyles,
                                               Consumer<SheetExport.Builder<T>> preparation,
                                               Supplier<StreamResult<T>> query) {

        SheetExport.Builder<T> exportBuilder = SheetExport.<T>builder()
            .name(nature.toString())
            .workbook(workbook)
            .styles(exportStyles);

        preparation.accept(exportBuilder);
        prepareAssetExportProperties(exportBuilder, nature);
        SheetExport<T> export = exportBuilder.build();

        try (StreamResult<T> assetStream = query.get()) {
            log.info("{} {} expected",
                assetStream.getEstimatedSize(),
                export.getName());

            export.export(assetStream);
        }
        log.info("{} {} found",
            export.getItemCount(),
            export.getName());
    }


    /**
     * Prépare l'export des colonnes principales des categories.
     *
     * @param builder Builder de l'objet d'export.
     */
    private void prepareCategoryExportMainSection(SheetExport.Builder<RichCategory> builder) {
        builder
            .addColumn(col ->
                col.label("Identifiant")
                    .width(ID_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getId())))
            .addColumn(col ->
                col.label("Category Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getName())))
            .addColumn(col ->
                col.label("Description")
                    .width(DESCRIPTION_WIDTH)
                    .exporter((writer, item) -> writer.writeDescription(item.getDescription())))
            .addColumn(col ->
                col.label("Last Update")
                    .width(TIMESTAMP_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getLastUpdate())))
            .addColumn(col ->
                col.label("tags")
                    .width(10)
                    .exporter((writer, item) -> {
                        List<String> tags = new ArrayList<>(item.getTags());
                        if (!tags.isEmpty()) {
                            tags.sort(String.CASE_INSENSITIVE_ORDER);
                            writer.write(String.join("\n", tags));
                        }
                    }))
            .addColumn(col ->
                col.label("Completion")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getCompletion())))
            .addColumn(col ->
                col.label("Datasets Completion")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDatasetCompletion())));
    }

    /**
     * Prépare l'export des colonnes principales des datasets.
     *
     * @param builder Builder de l'objet d'export.
     */
    private void prepareDatasetExportMainSection(SheetExport.Builder<RichDataset> builder) {
        builder
            .addColumn(col ->
                col.label("Identifiant")
                    .width(ID_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getId())))
            .addColumn(col ->
                col.label("Category Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getCategoryName())))
            .addColumn(col ->
                col.label("Dataset Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getName())))
            .addColumn(col ->
                col.label("Technical Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getTechnicalName())))
            .addColumn(col ->
                col.label("Data Storage Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDataStorageName())))
            .addColumn(col ->
                col.label("Data Storage Type")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDataStorageType())))
            .addColumn(col ->
                col.label("Path in Data Storage")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDatasetLocator().getPath().getPath())))
            .addColumn(col ->
                col.label("Description")
                    .width(DESCRIPTION_WIDTH)
                    .exporter((writer, item) -> writer.writeDescription(item.getDescription())))
            .addColumn(col ->
                col.label("Last Update")
                    .width(TIMESTAMP_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getLastUpdate())))
            .addColumn(col ->
                col.label("Last Integration")
                    .width(TIMESTAMP_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getLastIntegration())))
            .addColumn(col ->
                col.label("Record Number")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getNbRecord())))
            .addColumn(col ->
                col.label("File Number")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getNbFile())))
            .addColumn(col ->
                col.label("Size On Disk")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getSizeOnDisk())))
            .addColumn(col ->
                col.label("tags")
                    .width(10)
                    .exporter((writer, item) -> {
                        List<String> tags = new ArrayList<>(item.getTags());
                        if (!tags.isEmpty()) {
                            tags.sort(String.CASE_INSENSITIVE_ORDER);
                            writer.write(String.join("\n", tags));
                        }
                    }))
            .addColumn(col ->
                col.label("Completion")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getCompletion())));
    }

    /**
     * Prépare l'export des colonnes principales des champs (<i>fields</i>).
     *
     * @param builder Builder de l'objet d'export.
     */
    @SuppressWarnings("unchecked")
    private void prepareFieldExportMainSection(SheetExport.Builder<RichField> builder) {
        builder
            .addColumn(col ->
                col.label("Identifiant")
                    .width(ID_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getId())))
            .addColumn(col ->
                col.label("Dataset Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDatasetName())))
            .addColumn(col ->
                col.label("Index")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getNativeIndex())))
            .addColumn(col ->
                col.label("Field Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getName())))
            .addColumn(col ->
                col.label("Technical Name")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getTechnicalName())))
            .addColumn(col ->
                col.label("Data Type")
                    .width(TEXT_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getDataType())))
            .addColumn(col ->
                col.label("Description")
                    .width(DESCRIPTION_WIDTH)
                    .exporter((writer, item) -> writer.writeDescription(item.getDescription())))
            .addColumn(col ->
                col.label("Nullable")
                    .width(BOOLEAN_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getNullable())))
            .addColumn(col ->
                col.label("Multivalued")
                    .width(BOOLEAN_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getMultivalued())))
            .addColumn(col ->
                col.label("Primary Key")
                    .width(BOOLEAN_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getPrimaryKey())))
            .addColumn(col ->
                col.label("Last Update")
                    .width(TIMESTAMP_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getLastUpdate())))
            .addColumn(col ->
                col.label("Tags")
                    .width(10)
                    .exporter((writer, item) -> {
                        List<String> tags = new ArrayList<>(item.getTags());
                        if (!tags.isEmpty()) {
                            tags.sort(String.CASE_INSENSITIVE_ORDER);
                            writer.write(String.join("\n", tags));
                        }
                    }))
            .addColumn(col ->
                col.label("Concepts")
                    .width(10)
                    .exporter((writer, item) -> {
                        List<ConceptName> concepts = item.getConcepts();
                        if (!concepts.isEmpty()) {
                            writer.write(concepts.stream()
                                .map(ConceptName::getName)
                                .collect(Collectors.joining("\n")));
                        }
                    }))
            .addColumn(col ->
                col.label("Completion")
                    .width(NUMBER_WIDTH)
                    .exporter((writer, item) -> writer.write(item.getCompletion())));
    }

    /**
     * Prépare l'export des propriétés d'un asset.
     *
     * <h3>Détail d'implantation</h3>
     *
     * <p>Cette méthode appelle l'API Zeenea qui permet de récupérer le formulaire par défaut de l'asset à exporter.
     * A partir du résultat, il crée un groupe de colonnes par section et une colonne par proprété dans la section.</p>
     *
     * @param builder Builder de l'objet d'export.
     * @param target  Nature de l'asset à exporter.
     * @param <T>     Type de l'asset à Exporter.
     */
    private <T extends Asset> void prepareAssetExportProperties(SheetExport.Builder<T> builder, Nature target) {
        PropertyForm form = client.getPropertyApi().getDefaultPropertyFormByTarget(target);
        for (PropertySection formSection : form.getSections()) {
            builder.addGroup(groupBuilder -> {
                groupBuilder.label(formSection.getLabel());
                for (PropertyLine line : formSection.getLines()) {
                    for (Property property : line.getProperties()) {
                        groupBuilder.addColumn(ColumnExport.<T>builder()
                            .label(property.getLabel())
                            .width(widthByPropertyType(property.getPropertyType()))
                            .exporter((writer, item) -> propertyValueExporter(writer, property, item))
                            .build());
                    }
                }
            });
        }
    }

    /**
     * Détermine la taille de la colonne Excel en fonction du type de la propriété.
     *
     * @param propertyType Type de la propriété.
     * @return Taille de la colonne en nombre de caractères.
     */
    private int widthByPropertyType(PropertyType propertyType) {
        switch (propertyType) {
            case ShortText:
            case Enum:
                return TEXT_WIDTH;
            case RichText:
            case Url:
                return DESCRIPTION_WIDTH;
            case Number:
                return NUMBER_WIDTH;
            case TimeStamp:
                return TIMESTAMP_WIDTH;
            default:
                return 0;
        }
    }

    /**
     * Méthode qui permet l'extraction de la valeur d'une propriété d'une instance d'un asset et de l'écrire dans une
     * cellule de la feuille Excel.
     *
     * @param writer   L'objet d'écriture d'une cellule Excel.
     * @param property Propriété Zeenea.
     * @param item     Instance de l'asset dont on veux extraire la propriété.
     * @param <T>      Type de l'asset.
     */
    private <T extends Asset> void propertyValueExporter(SheetExport.Writer writer, Property property, T item) {
        PropertyValue propertyValue = item.getProperties().get(property.getId());

        if (propertyValue == null) return;

        switch (property.getPropertyType()) {
            case Enum:
            case ShortText:
                if (propertyValue.isText()) {
                    writer.write(propertyValue.asText().getRaw());
                } else {
                    writer.write("## Not a text ##");
                }
                break;

            case RichText:
                if (propertyValue.isText()) {
                    writer.writeDescription(propertyValue.asText().getRaw());
                } else {
                    writer.write("## Not a text ##");
                }
                break;

            case Number:
                if (propertyValue.isNumber()) {
                    writer.write(propertyValue.asNumber().getRaw());
                } else {
                    writer.write("## Not a number ##");
                }
                break;

            case TimeStamp:
                if (propertyValue.isText()) {
                    try {
                        writer.write(Instant.parse(propertyValue.asText().getRaw()));
                    } catch (DateTimeParseException e) {
                        writer.write("## Not a timestamp ##");
                    }
                } else {
                    writer.write("## Not a timestamp ##");
                }
                break;

            case Url:
                if (propertyValue.isUrl()) {
                    UrlValue url = propertyValue.asUrl();
                    try {
                        writer.writeHyperlink(url.getLabel(), url.getUrl());
                    } catch (Exception e) {
                        StringBuilder sb = new StringBuilder();
                        sb.append(url.getUrl());
                        if (url.getLabel() != null) {
                            sb.append(' ');
                            sb.append(url.getLabel());
                        }
                        writer.write(sb.toString());
                    }

                } else {
                    writer.write("## Not an URL ##");
                }

            default:
                break;
        }
    }


    /**
     * Ouvre le fichier d'export Excel.
     *
     * <p>La destination du fichier est définie par la valeur de {@link ExportParams#getOutputFile() outputFile}
     * de la configuration.</p>
     *
     * <p>Par défaut, l'export échoue si le fichier d'export existe déjà. Le fichier existant est conservé intact.</p>
     * <p>Ce comportement peut être modifier en chageant l'option {@link ExportParams#isOverrideExistingOutput() overrideExistingOutput}.
     * Lorsque sa valeur est {@code true}, le fichier d'export existant est écrassé par l'export.</p>
     *
     * @return un {@link OutputStream}
     * @throws IOException Si le fichier ne peut être ouvert.
     */
    private OutputStream openExportFile() throws IOException {
        Path outputFilePath = params.getOutputFile();
        log.info("Write result to {}", outputFilePath);
        OpenOption[] options;
        if (params.isOverrideExistingOutput()) {
            options = new OpenOption[]{StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING};
        } else {
            options = new OpenOption[]{StandardOpenOption.CREATE_NEW};
        }
        return Files.newOutputStream(outputFilePath, options);
    }


}
